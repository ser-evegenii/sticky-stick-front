"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createContext = createContext;

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/toConsumableArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/objectSpread"));

var _asyncUntil = _interopRequireDefault(require("async-until"));

var _react = _interopRequireDefault(require("react"));

var _reactCosmosStateProxy = _interopRequireDefault(require("react-cosmos-state-proxy"));

var _Loader = require("./components/Loader");

var _isRefSupported = require("./utils/is-ref-supported");

var wrapper;
var StateProxy = (0, _reactCosmosStateProxy.default)({
  updateInterval: 50
});
/**
 * Generalized way to render fixtures, without any assumptions on the renderer.
 *
 * The fixture context records state changes received from the rendered proxy
 * chain and provides helper methods for reading the latest state (via get) or
 * subscribing to all updates (via onUpdate). The former is used in headless
 * test environments while the latter in the Playground UI's "fixture editor".
 *
 * Important: Because some proxies are global by nature (eg. fetch-proxy mocks
 * window.fetch) there can only be one active context per page. This means that
 * mounting a new context will unmount the previous automatically.
 */

function createContext(args) {
  var renderer = args.renderer,
      rendererOptions = args.rendererOptions,
      _args$proxies = args.proxies,
      proxies = _args$proxies === void 0 ? [] : _args$proxies,
      fixture = args.fixture,
      onUpdate = args.onUpdate,
      beforeInit = args.beforeInit;
  var updatedFixture = (0, _objectSpread2.default)({}, fixture);
  var compRefCalled = false;
  var compRef;

  function getRef() {
    if (!compRef) {
      throw new Error("Component ref is not available yet. Did you mount() the context?");
    }

    return compRef;
  }

  function getWrapper() {
    if (!wrapper) {
      throw new Error("Context wrapper hasn't been created yet. Did you mount() the context?");
    }

    return wrapper;
  }

  function get(fixtureKey) {
    return fixtureKey ? updatedFixture[fixtureKey] : updatedFixture;
  }

  function update(fixturePart) {
    updatedFixture = (0, _objectSpread2.default)({}, updatedFixture, fixturePart);

    if (onUpdate) {
      onUpdate(fixturePart);
    }
  }

  function mount() {
    var clearPrevInstance = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    return new _promise.default(
    /*#__PURE__*/
    function () {
      var _ref = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee(resolve, reject) {
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;

                if (clearPrevInstance) {
                  unmount(); // Bring fixture to its initial state

                  updatedFixture = (0, _objectSpread2.default)({}, fixture);
                }

                wrapper = renderer(_react.default.createElement(_Loader.Loader, {
                  proxies: (0, _toConsumableArray2.default)(proxies).concat([StateProxy]),
                  fixture: updatedFixture,
                  onComponentRef: function onComponentRef(ref) {
                    // Sometimes the component unmounts instantly (eg. redirects on
                    // componentWillMount and parent HoC doesn't render it anymore).
                    // In this cases compRef will be null but we'll know that the
                    // component rendered
                    compRefCalled = true;
                    compRef = ref;
                  },
                  onFixtureUpdate: update
                }), rendererOptions); // Ensure component ref is available when mounting is resolved (esp.
                // convenient in headless tests)

                if (!(0, _isRefSupported.isRefSupported)(fixture.component)) {
                  _context.next = 6;
                  break;
                }

                _context.next = 6;
                return (0, _asyncUntil.default)(function () {
                  return compRefCalled;
                });

              case 6:
                if (!beforeInit) {
                  _context.next = 9;
                  break;
                }

                _context.next = 9;
                return beforeInit();

              case 9:
                if (!fixture.init) {
                  _context.next = 12;
                  break;
                }

                _context.next = 12;
                return fixture.init({
                  compRef: compRef
                });

              case 12:
                resolve();
                _context.next = 18;
                break;

              case 15:
                _context.prev = 15;
                _context.t0 = _context["catch"](0);
                reject(_context.t0);

              case 18:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[0, 15]]);
      }));

      return function (_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }());
  }

  function unmount() {
    if (wrapper) {
      wrapper.unmount();
      wrapper = undefined;
    }
  }

  return {
    mount: mount,
    unmount: unmount,
    getRef: getRef,
    getWrapper: getWrapper,
    get: get,
    getField: get
  };
}
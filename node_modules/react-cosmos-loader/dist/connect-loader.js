"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.connectLoader = connectLoader;

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/objectSpread"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));

var _lodash = _interopRequireDefault(require("lodash.merge"));

var _reactCosmosShared = require("react-cosmos-shared");

var _createContext2 = require("./create-context");

var unbindPrev; // This will be populated on fixtureSelect events

var selected; // The fixture cache can contain
// - Fixture updates received from proxy chain via context's onUpdate handler
// - Fixture edits received from Playground UI
// The cache is cleared when a fixture (including the current one) is selected

var fixtureCache;
/**
 * Connect fixture context (Loader) to remote Cosmos UI via configurable
 * communication channel (eg. window.postMessage or websockets)
 *
 * It both receives fixture edits from UI and forwards fixture updates bubbled
 * up from proxy chain (due to state changes) to UI.
 */

function connectLoader(_x) {
  return _connectLoader.apply(this, arguments);
}

function _connectLoader() {
  _connectLoader = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee3(args) {
    var proxies, fixtures, renderer, subscribe, unsubscribe, sendMessage, dismissRuntimeErrors, loadFixture, _loadFixture, onContextUpdate, onMessage, _onMessage, bind, unbind, isFirstCall, _selected2, component, fixture, originalFixture;

    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            unbind = function _ref7() {
              unsubscribe();
              unbindPrev = undefined;
            };

            bind = function _ref6() {
              subscribe(onMessage);
            };

            _onMessage = function _ref5() {
              _onMessage = (0, _asyncToGenerator2.default)(
              /*#__PURE__*/
              _regenerator.default.mark(function _callee2(msg) {
                var _component, _fixture, selectedFixture, _selected3, _component2, _fixture2;

                return _regenerator.default.wrap(function _callee2$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        if (!(msg.type === 'uiReady')) {
                          _context2.next = 4;
                          break;
                        }

                        // This is called in the native loader, where the UI can load second
                        sendMessage({
                          type: 'loaderReady',
                          fixtures: extractFixtureNames(fixtures)
                        });
                        _context2.next = 27;
                        break;

                      case 4:
                        if (!(msg.type === 'fixtureSelect')) {
                          _context2.next = 18;
                          break;
                        }

                        _component = msg.component, _fixture = msg.fixture;

                        if (!(fixtures[_component] && fixtures[_component][_fixture])) {
                          _context2.next = 15;
                          break;
                        }

                        selected = {
                          component: _component,
                          fixture: _fixture
                        }; // No need for a cache at this point. Until a fixtureUpdate or
                        // fixtureEdit event is receved, fixture source changes will be
                        // applied immediately.

                        fixtureCache = undefined;
                        selectedFixture = fixtures[_component][_fixture];
                        _context2.next = 12;
                        return loadFixture(selectedFixture);

                      case 12:
                        if (dismissRuntimeErrors) {
                          dismissRuntimeErrors();
                        }

                        _context2.next = 16;
                        break;

                      case 15:
                        console.error("[Cosmos] Missing fixture for ".concat(String(_component), ":").concat(String(_fixture)));

                      case 16:
                        _context2.next = 27;
                        break;

                      case 18:
                        if (!(msg.type === 'fixtureEdit')) {
                          _context2.next = 27;
                          break;
                        }

                        if (selected) {
                          _context2.next = 23;
                          break;
                        }

                        console.error('[Cosmos] No selected fixture to edit');
                        _context2.next = 27;
                        break;

                      case 23:
                        // This can be the first edit after a fixture was selected
                        if (!fixtureCache) {
                          _selected3 = selected, _component2 = _selected3.component, _fixture2 = _selected3.fixture;
                          fixtureCache = fixtures[_component2][_fixture2];
                        } // NOTE: Edits override the entire (serializable) fixture body


                        fixtureCache = applyFixtureBody(fixtureCache, msg.fixtureBody); // Note: Creating fixture context from scratch on every fixture edit.
                        // This means that the component will always go down the
                        // componentDidMount path (instead of componentWillReceiveProps) when
                        // user edits fixture via fixture editor. In the future we might want
                        // to sometimes update the fixture context instead of resetting it.

                        _context2.next = 27;
                        return loadFixture(fixtureCache, false);

                      case 27:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, _callee2, this);
              }));
              return _onMessage.apply(this, arguments);
            };

            onMessage = function _ref4(_x3) {
              return _onMessage.apply(this, arguments);
            };

            onContextUpdate = function _ref3(fixturePart) {
              if (!selected) {
                return;
              } // This can be the first update after a fixture was selected


              if (!fixtureCache) {
                var _selected = selected,
                    component = _selected.component,
                    fixture = _selected.fixture;
                fixtureCache = fixtures[component][fixture];
              } // NOTE: Updates extend the fixture fields
              // Apply the entire updated fixture part...


              fixtureCache = applyFixturePart(fixtureCache, fixturePart); // ...but only the serializable part can be sent to parent

              var _splitUnserializableP2 = (0, _reactCosmosShared.splitUnserializableParts)(fixturePart),
                  serializable = _splitUnserializableP2.serializable;

              sendMessage({
                type: 'fixtureUpdate',
                fixtureBody: serializable
              });
            };

            _loadFixture = function _ref2() {
              _loadFixture = (0, _asyncToGenerator2.default)(
              /*#__PURE__*/
              _regenerator.default.mark(function _callee(fixture) {
                var notifyParent,
                    _createContext,
                    mount,
                    _splitUnserializableP3,
                    serializable,
                    _args = arguments;

                return _regenerator.default.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        notifyParent = _args.length > 1 && _args[1] !== undefined ? _args[1] : true;
                        _createContext = (0, _createContext2.createContext)({
                          renderer: renderer,
                          proxies: proxies,
                          fixture: fixture,
                          onUpdate: onContextUpdate
                        }), mount = _createContext.mount;
                        _context.next = 4;
                        return mount();

                      case 4:
                        if (notifyParent) {
                          // Notify back parent with the serializable contents of the loaded fixture
                          _splitUnserializableP3 = (0, _reactCosmosShared.splitUnserializableParts)(fixture), serializable = _splitUnserializableP3.serializable;
                          sendMessage({
                            type: 'fixtureLoad',
                            fixtureBody: serializable
                          });
                        }

                      case 5:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee, this);
              }));
              return _loadFixture.apply(this, arguments);
            };

            loadFixture = function _ref(_x2) {
              return _loadFixture.apply(this, arguments);
            };

            proxies = args.proxies, fixtures = args.fixtures, renderer = args.renderer, subscribe = args.subscribe, unsubscribe = args.unsubscribe, sendMessage = args.sendMessage, dismissRuntimeErrors = args.dismissRuntimeErrors;
            isFirstCall = !unbindPrev; // Implicitly unbind prev context when new one is created

            if (unbindPrev) {
              unbindPrev();
            }

            unbindPrev = unbind; // Always bind onMessage handler to latest input

            bind();

            if (!isFirstCall) {
              _context3.next = 16;
              break;
            }

            // Let parent know loader is ready to render, along with the initial
            // fixture list (which might update later due to HMR)
            sendMessage({
              type: 'loaderReady',
              fixtures: extractFixtureNames(fixtures)
            });
            _context3.next = 32;
            break;

          case 16:
            // Keep parent up to date with fixture list
            sendMessage({
              type: 'fixtureListUpdate',
              fixtures: extractFixtureNames(fixtures)
            });

            if (!selected) {
              _context3.next = 32;
              break;
            }

            // Use the fixture cache contents if present, but always re-create the
            // context to ensure latest proxies and components are used.
            _selected2 = selected, component = _selected2.component, fixture = _selected2.fixture;
            originalFixture = fixtures[component][fixture];

            if (originalFixture) {
              _context3.next = 25;
              break;
            }

            // Maybe fixture was renamed
            selected = undefined;
            fixtureCache = undefined;
            _context3.next = 32;
            break;

          case 25:
            if (!fixtureCache) {
              _context3.next = 30;
              break;
            }

            _context3.next = 28;
            return loadFixture((0, _objectSpread2.default)({}, fixtureCache, {
              component: originalFixture.component
            }));

          case 28:
            _context3.next = 32;
            break;

          case 30:
            _context3.next = 32;
            return loadFixture(originalFixture);

          case 32:
            return _context3.abrupt("return", function destroy() {
              if (unbindPrev) {
                unbindPrev();
                selected = undefined;
                fixtureCache = undefined;
              }
            });

          case 33:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _connectLoader.apply(this, arguments);
}

function extractFixtureNames(fixtures) {
  return (0, _keys.default)(fixtures).reduce(function (acc, next) {
    acc[next] = (0, _keys.default)(fixtures[next]);
    return acc;
  }, {});
}

function applyFixturePart(currentFixture, fixturePart) {
  return (0, _objectSpread2.default)({}, currentFixture, fixturePart);
}

function applyFixtureBody(currentFixture, fixtureBody) {
  var _splitUnserializableP = (0, _reactCosmosShared.splitUnserializableParts)(currentFixture),
      unserializable = _splitUnserializableP.unserializable;

  return (0, _lodash.default)({}, unserializable, fixtureBody);
}
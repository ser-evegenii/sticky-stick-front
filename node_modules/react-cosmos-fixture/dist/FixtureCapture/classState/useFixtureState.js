"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
var React = require("react");
var lodash_1 = require("lodash");
var fixtureState_1 = require("react-cosmos-shared2/fixtureState");
var FixtureContext_1 = require("../../FixtureContext");
var findRelevantElementPaths_1 = require("../shared/findRelevantElementPaths");
var shared_1 = require("./shared");
var decorateFixtureRefs_1 = require("./decorateFixtureRefs");
function useFixtureState(children, decoratorId, elRefs) {
    var elPaths = findRelevantElementPaths_1.findRelevantElementPaths(children);
    var _a = React.useContext(FixtureContext_1.FixtureContext), fixtureState = _a.fixtureState, setFixtureState = _a.setFixtureState;
    var lastFixtureState = useFixtureStateRef(fixtureState);
    // Keep a copy of the previous fixture state to observe changes
    var prevFixtureState = React.useRef(fixtureState);
    // Remember initial state of child components to use as a default when
    // resetting fixture state
    var initialStates = React.useRef({});
    // Ref handlers are reused because every time we pass a new ref handler to
    // a React element it gets called in the next render loop, even when the
    // associated element instance has been preserved. Having ref handlers fire
    // on every render loop results in unwanted operations and race conditions.
    var cachedRefHandlers = React.useRef({});
    shared_1.useUnmount(function () {
        initialStates.current = {};
        cachedRefHandlers.current = {};
    });
    React.useEffect(function () {
        // Remove fixture state for removed child elements (likely via HMR)
        // FIXME: Also invalidate fixture state at this element path if the
        // component type of the corresponding element changed
        var fsProps = fixtureState_1.getFixtureStateClassState(fixtureState, decoratorId);
        fsProps.forEach(function (_a) {
            var elementId = _a.elementId;
            var elPath = elementId.elPath;
            if (elPaths.indexOf(elementId.elPath) === -1) {
                setFixtureState(function (prevFs) { return (__assign({}, prevFs, { classState: fixtureState_1.removeFixtureStateClassState(fixtureState, elementId) })); });
                if (elRefs.current[elPath]) {
                    delete elRefs.current[elPath];
                    delete initialStates.current[elPath];
                    delete cachedRefHandlers.current[elPath];
                }
            }
        });
        elPaths.forEach(function (elPath) {
            var elementId = { decoratorId: decoratorId, elPath: elPath };
            // Component fixture state can be provided before the fixture mounts (eg.
            // a previous snapshot of a fixture state or the current fixture state
            // from another renderer)
            var fsClassState = fixtureState_1.findFixtureStateClassState(fixtureState, elementId);
            if (!fsClassState) {
                if (initialStates.current[elPath]) {
                    var state_1 = initialStates.current[elPath].state;
                    var elRef = elRefs.current[elPath];
                    if (!lodash_1.isEqual(elRef.state, state_1)) {
                        shared_1.replaceState(elRef, state_1);
                    }
                    setFixtureState(function (prevFs) { return (__assign({}, prevFs, { classState: fixtureState_1.createFixtureStateClassState({
                            fixtureState: prevFs,
                            elementId: elementId,
                            values: fixtureState_1.createValues(state_1)
                        }) })); });
                }
            }
            else {
                var elRef = elRefs.current[elPath];
                // The el ref can be missing for three reasons:
                //   1. Element type is stateless
                //   2. Element type is a class, but doesn't have state. An instance exists
                //      but has been discarded because of its lack of state.
                //   3. Element instance unmounted and is about to remount. When this
                //      happens, the new instance will be handled when its ref fires again.
                if (!elRef) {
                    return;
                }
                // The child's state can be out of sync with the fixture state for two
                // reasons:
                //   1. The child's state changed internally
                //   2. The fixture state changed
                // Here we're interested in the second scenario. In the first scenario
                // we want to let the component state override the fixture state.
                var prevFsClassState = fixtureState_1.findFixtureStateClassState(prevFixtureState.current, elementId);
                if (prevFsClassState && !lodash_1.isEqual(prevFsClassState, fsClassState)) {
                    return shared_1.replaceState(elRef, fixtureState_1.extendWithValues(elRef.state, fsClassState.values));
                }
            }
        });
    }, [setFixtureState, children, fixtureState.classState]);
    // Update prev fixture state ref *after* running effects that reference it
    React.useEffect(function () {
        prevFixtureState.current = fixtureState;
    });
    return decorateFixtureRefs_1.decorateFixtureRefs(children, handleRef, cachedRefHandlers.current);
    function handleRef(elPath, elRef) {
        if (!elRef) {
            delete elRefs.current[elPath];
            return;
        }
        // Only track instances with state
        var state = elRef.state;
        if (!state) {
            return;
        }
        elRefs.current[elPath] = elRef;
        setInitialState(initialStates.current, elPath, elRef);
        var elementId = { decoratorId: decoratorId, elPath: elPath };
        var fsClassState = fixtureState_1.findFixtureStateClassState(lastFixtureState.current, elementId);
        if (!fsClassState) {
            setFixtureState(function (prevFs) { return (__assign({}, prevFs, { classState: fixtureState_1.createFixtureStateClassState({
                    fixtureState: prevFs,
                    elementId: elementId,
                    values: fixtureState_1.createValues(state)
                }) })); });
        }
        else {
            shared_1.replaceState(elRef, fixtureState_1.extendWithValues(state, fsClassState.values));
        }
    }
}
exports.useFixtureState = useFixtureState;
// Make latest fixture state accessible in ref callback
function useFixtureStateRef(fixtureState) {
    var ref = React.useRef(fixtureState);
    React.useEffect(function () {
        ref.current = fixtureState;
    });
    return ref;
}
function setInitialState(initialStates, elPath, elRef) {
    var found = initialStates[elPath];
    var type = elRef.constructor;
    // Keep the first state recevied for this type
    var initialStateExists = found && found.type === type;
    if (!initialStateExists && elRef.state) {
        initialStates[elPath] = { type: type, state: elRef.state };
    }
}

"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
var fixtureState_1 = require("react-cosmos-shared2/fixtureState");
var nodeTree_1 = require("../shared/nodeTree");
var findRelevantElementPaths_1 = require("../shared/findRelevantElementPaths");
var componentName_1 = require("./componentName");
function extendFixtureProps(fixture, fixtureState, decoratorId) {
    var elPaths = findRelevantElementPaths_1.findRelevantElementPaths(fixture);
    return elPaths.reduce(function (extendedFixture, elPath) {
        var elementId = { decoratorId: decoratorId, elPath: elPath };
        var fsProps = fixtureState_1.findFixtureStateProps(fixtureState, elementId);
        return nodeTree_1.setElementAtPath(extendedFixture, elPath, function (element) {
            if (!fsProps || componentTypeChanged(fsProps.componentName)) {
                return __assign({}, element, { key: getElRenderKey(elPath, fixtureState_1.DEFAULT_RENDER_KEY) });
            }
            // Prevent overriding child elements with outdated "children" prop values
            // stored in fixture state
            // See https://github.com/react-cosmos/react-cosmos/pull/920 for context
            var originalProps = element.props;
            var extendedProps = fixtureState_1.extendWithValues(originalProps, fsProps.values);
            // HACK alert: Editing React Element by hand
            // This is blasphemy, but there are two reasons why React.cloneElement
            // isn't ideal:
            //   1. Props need to overridden (not merged)
            //   2. element.key has to be set to control whether the prev instance
            //      should be reused on not
            // Still, in case this method causes trouble in the future, both reasons
            // can be overcome in the following ways:
            //   1. Set original props that aren't present in fixture state to
            //      undefined
            //   2. Create a wrapper component or element and to set the key on
            // Useful links:
            //   - https://reactjs.org/docs/react-api.html#cloneelement
            //   - https://github.com/facebook/react/blob/15a8f031838a553e41c0b66eb1bcf1da8448104d/packages/react/src/ReactElement.js#L293-L362
            return __assign({}, element, { props: hasChildElPaths(elPaths, elPath)
                    ? __assign({}, extendedProps, { children: originalProps.children }) : extendedProps, key: getElRenderKey(elPath, fsProps.renderKey) });
            function componentTypeChanged(componentName) {
                return componentName !== componentName_1.getComponentName(element.type);
            }
        });
    }, fixture);
}
exports.extendFixtureProps = extendFixtureProps;
function getElRenderKey(elPath, renderKey) {
    return elPath + "-" + renderKey;
}
function hasChildElPaths(elPaths, elPath) {
    return elPaths.some(function (p) { return p.indexOf(nodeTree_1.getChildrenPath(elPath)) === 0; });
}

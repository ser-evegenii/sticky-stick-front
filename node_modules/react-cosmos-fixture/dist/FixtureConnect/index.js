"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
var React = require("react");
var lodash_1 = require("lodash");
var FixtureProvider_1 = require("../FixtureProvider");
var fixtureHelpers_1 = require("./fixtureHelpers");
// TODO: Add props for customizing blank/missing states: `getBlankState` and
// `getMissingState`
var FixtureConnect = /** @class */ (function (_super) {
    __extends(FixtureConnect, _super);
    function FixtureConnect() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            selectedFixture: null,
            renderKey: 0
        };
        _this.handleRequest = function (msg) {
            if (msg.type === 'pingRenderers') {
                return _this.postReadyState();
            }
            if (!msg.payload || msg.payload.rendererId !== _this.props.rendererId) {
                return;
            }
            if (doesRequestChangeFixture(msg)) {
                _this.fireChangeCallback();
            }
            switch (msg.type) {
                case 'selectFixture':
                    return _this.handleSelectFixtureRequest(msg);
                case 'unselectFixture':
                    return _this.handleUnselectFixtureRequest();
                case 'setFixtureState':
                    return _this.handleSetFixtureStateRequest(msg);
                default:
                // This Is Fineâ„¢
                // Actually, we can't be angry about getting unrelated messages here
                // because we don't do any preliminary message filtering to ignore stuff
                // like browser devtools communication, nor do we have any message
                // metadata conventions in place to perform such filtering at the moment
            }
        };
        _this.setFixtureState = function (stateUpdate, cb) {
            if (!_this.state.selectedFixture) {
                console.warn('[FixtureConnect] Trying to set fixture state with no fixture selected');
                return;
            }
            // Multiple state changes can be dispatched by fixture plugins at almost
            // the same time. Since state changes are batched in React, current state
            // (this.state.fixtureState) can be stale at dispatch time, and extending
            // it can result in cancelling previous state changes that are queued.
            // Using an updater function like ({ prevState }) => nextState ensures
            // every state change is honored, regardless of timing.
            _this.setState(function (_a) {
                var selectedFixture = _a.selectedFixture;
                if (!selectedFixture) {
                    return null;
                }
                return {
                    selectedFixture: __assign({}, selectedFixture, { fixtureState: stateUpdate(selectedFixture.fixtureState) })
                };
            }, cb);
        };
        _this.postFixtureStateChange = function (fixtureId, fixtureState) {
            var _a = _this.props, rendererId = _a.rendererId, postMessage = _a.postMessage;
            postMessage({
                type: 'fixtureStateChange',
                payload: {
                    rendererId: rendererId,
                    fixtureId: fixtureId,
                    fixtureState: fixtureState
                }
            });
        };
        return _this;
    }
    FixtureConnect.prototype.componentDidMount = function () {
        var subscribe = this.props.subscribe;
        subscribe(this.handleRequest);
        this.postReadyState();
    };
    FixtureConnect.prototype.componentDidUpdate = function (prevProps) {
        var fixtures = this.props.fixtures;
        if (!lodash_1.isEqual(fixtures, prevProps.fixtures)) {
            this.postFixtureListUpdate();
        }
        var selectedFixture = this.state.selectedFixture;
        if (selectedFixture) {
            var fixtureId = selectedFixture.fixtureId, fixtureState = selectedFixture.fixtureState, syncedFixtureState = selectedFixture.syncedFixtureState;
            if (fixtureId && !lodash_1.isEqual(fixtureState, syncedFixtureState)) {
                this.postFixtureStateChange(fixtureId, fixtureState);
                this.updateSyncedFixtureState(syncedFixtureState);
            }
        }
    };
    FixtureConnect.prototype.componentWillUnmount = function () {
        this.props.unsubscribe();
    };
    FixtureConnect.prototype.shouldComponentUpdate = function (prevProps, prevState) {
        // This check exists mainly to prevent updating the fixture tree when
        // fixture state setters resulted in no fixture state change
        return !lodash_1.isEqual(this.props, prevProps) || !lodash_1.isEqual(this.state, prevState);
    };
    FixtureConnect.prototype.render = function () {
        var selectedFixture = this.state.selectedFixture;
        if (!selectedFixture) {
            return 'No fixture loaded.';
        }
        var fixtures = this.props.fixtures;
        var fixtureId = selectedFixture.fixtureId, fixtureState = selectedFixture.fixtureState;
        // Falsy check doesn't do because fixtures can be any Node, including
        // null or undefined.
        if (!fixtures.hasOwnProperty(fixtureId.path)) {
            return "Fixture path not found: " + fixtureId.path;
        }
        var fixtureExport = fixtures[fixtureId.path];
        var fixture = fixtureHelpers_1.getFixtureNode(fixtureExport, fixtureId.name);
        if (typeof fixture === 'undefined') {
            return "Invalid fixture ID: " + JSON.stringify(fixtureId);
        }
        var _a = this.props, systemDecorators = _a.systemDecorators, userDecorators = _a.userDecorators;
        var renderKey = this.state.renderKey;
        return (React.createElement(FixtureProvider_1.FixtureProvider
        // renderKey controls whether to reuse previous instances (and
        // transition props) or rebuild render tree from scratch
        , { 
            // renderKey controls whether to reuse previous instances (and
            // transition props) or rebuild render tree from scratch
            key: renderKey, decorators: getSortedDecoratorsForFixturePath(systemDecorators, userDecorators, fixtureId.path), fixtureState: fixtureState, setFixtureState: this.setFixtureState }, fixture));
    };
    FixtureConnect.prototype.handleSelectFixtureRequest = function (_a) {
        var payload = _a.payload;
        var fixtureId = payload.fixtureId, fixtureState = payload.fixtureState;
        this.setState({
            selectedFixture: {
                fixtureId: fixtureId,
                fixtureState: fixtureState,
                syncedFixtureState: fixtureState
            },
            renderKey: this.state.renderKey + 1
        });
    };
    FixtureConnect.prototype.handleUnselectFixtureRequest = function () {
        this.setState({
            selectedFixture: null,
            renderKey: 0
        });
    };
    FixtureConnect.prototype.handleSetFixtureStateRequest = function (_a) {
        var payload = _a.payload;
        var fixtureId = payload.fixtureId, fixtureState = payload.fixtureState;
        var selectedFixture = this.state.selectedFixture;
        // Ensure fixture state applies to currently selected fixture
        if (selectedFixture && lodash_1.isEqual(fixtureId, selectedFixture.fixtureId)) {
            this.setState({
                selectedFixture: {
                    fixtureId: fixtureId,
                    fixtureState: fixtureState,
                    syncedFixtureState: fixtureState
                }
            });
        }
    };
    FixtureConnect.prototype.postReadyState = function () {
        var _a = this.props, rendererId = _a.rendererId, postMessage = _a.postMessage;
        postMessage({
            type: 'rendererReady',
            payload: {
                rendererId: rendererId,
                fixtures: this.getFixtureNames()
            }
        });
    };
    FixtureConnect.prototype.postFixtureListUpdate = function () {
        var _a = this.props, rendererId = _a.rendererId, postMessage = _a.postMessage;
        postMessage({
            type: 'fixtureListUpdate',
            payload: {
                rendererId: rendererId,
                fixtures: this.getFixtureNames()
            }
        });
    };
    FixtureConnect.prototype.getFixtureNames = function () {
        return fixtureHelpers_1.getFixtureNames(this.props.fixtures);
    };
    FixtureConnect.prototype.fireChangeCallback = function () {
        var onFixtureChange = this.props.onFixtureChange;
        if (typeof onFixtureChange === 'function') {
            onFixtureChange();
        }
    };
    FixtureConnect.prototype.updateSyncedFixtureState = function (syncedFixtureState) {
        this.setState(function (_a) {
            var selectedFixture = _a.selectedFixture;
            if (!selectedFixture) {
                return null;
            }
            // Other updates that alter state.selectedFixture can be pending when this
            // update is submitted. Those updates will be applied first. With this in
            // mind, we use a state setter callback to only override syncedFixtureState
            // and keep the latest values of other state parts.
            return {
                selectedFixture: __assign({}, selectedFixture, { syncedFixtureState: syncedFixtureState })
            };
        });
    };
    return FixtureConnect;
}(React.Component));
exports.FixtureConnect = FixtureConnect;
function getSortedDecoratorsForFixturePath(systemDecorators, decorators, fixturePath) {
    return systemDecorators.concat(getSortedDecorators(getDecoratorsForFixturePath(decorators, fixturePath)));
}
function getSortedDecorators(decorators) {
    return sortPathsByDepthAsc(Object.keys(decorators)).map(function (decoratorPath) { return decorators[decoratorPath]; });
}
function sortPathsByDepthAsc(paths) {
    return paths.slice().sort(function (a, b) {
        return getPathNestingLevel(a) - getPathNestingLevel(b) || a.localeCompare(b);
    });
}
function getPathNestingLevel(path) {
    return path.split('/').length;
}
function getDecoratorsForFixturePath(decorators, fixturePath) {
    return Object.keys(decorators)
        .filter(function (decPath) { return fixturePath.indexOf(getParentPath(decPath) + "/") === 0; })
        .reduce(function (acc, decPath) {
        var _a;
        return (__assign({}, acc, (_a = {}, _a[decPath] = decorators[decPath], _a)));
    }, {});
}
function getParentPath(nestedPath) {
    // Remove everything right of the right-most forward slash, or return an
    // empty string if path has no forward slash
    return nestedPath.replace(/^((.+)\/)?.+$/, '$2');
}
function doesRequestChangeFixture(r) {
    return r.type === 'selectFixture' || r.type === 'unselectFixture';
}

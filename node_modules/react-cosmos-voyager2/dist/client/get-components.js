"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getComponents = getComponents;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/objectSpread"));

var _getIterator2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/get-iterator"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/toConsumableArray"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));

var _isArray = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/array/is-array"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/map"));

var _set = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/set"));

var _lodash = require("lodash");

var _inferComponentName = require("./utils/infer-component-name");

var _defaultNamer = require("./utils/default-namer");

var _dir = require("./utils/dir");

function getComponents(_ref) {
  var fixtureFiles = _ref.fixtureFiles,
      fixtureModules = _ref.fixtureModules;
  var incompatFixtures = new _set.default();
  var fixturesByComponent = new _map.default();
  var componentNames = new _map.default();
  var componentPaths = new _map.default();
  fixtureFiles.forEach(function (fixtureFile) {
    var filePath = fixtureFile.filePath;
    var module = fixtureModules[filePath];

    if (!module) {
      console.log("[Cosmos] Missing module for ".concat(filePath));
      return;
    }

    var fileName = getFileNameFromPath(filePath);
    var fileFixtureNamer = (0, _defaultNamer.createDefaultNamer)(fileName); // Fixture files can export one fixture object or a list of fixture object

    var fixturesInFile = (0, _isArray.default)(module) ? module : [module];
    fixturesInFile.forEach(function (fixture, fixtureIndex) {
      var component = fixture.component,
          name = fixture.name;

      if (!fixture.component) {
        incompatFixtures.add(filePath);
        return;
      } // Is this the first fixture for this component?


      var compFixtures = fixturesByComponent.get(component);

      if (!compFixtures) {
        compFixtures = [];
        fixturesByComponent.set(component, compFixtures);
      }

      compFixtures.push({
        filePath: filePath,
        name: name || fileFixtureNamer(fixture.component),
        // Note: namespace is updated later, after gathering all fixtures per
        // component
        namespace: '',
        // namespace,
        source: fixture
      }); // Prepare for component info to be an empty list

      var componentInfo = fixtureFile.components[fixtureIndex];

      if (componentInfo) {
        // Stop at the first name found. Different names for the same component
        // can be found in future fixtures but will be ignored.
        if (!componentNames.get(component) && componentInfo.name) {
          componentNames.set(component, componentInfo.name);
        } // It's possible to identify the component name but not the file path


        if (!componentPaths.get(component) && componentInfo.filePath) {
          componentPaths.set(component, componentInfo.filePath);
        }
      }
    });
  });

  if (incompatFixtures.size > 0) {
    var fixtureCommonDir = (0, _dir.getCommonDir)((0, _keys.default)(fixtureModules));
    warnAboutIncompatFixtures(incompatFixtures, fixtureCommonDir);
  } // Add component meta data around fixtures


  var components = [];
  var componentPathValues = (0, _toConsumableArray2.default)(componentPaths.values());
  var defaultComponentNamer = (0, _defaultNamer.createDefaultNamer)('Component');
  var componentNamers = new _map.default();
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    var _loop = function _loop() {
      var componentType = _step.value;
      var compFixtures = fixturesByComponent.get(componentType);

      if (!compFixtures) {
        return "continue";
      }

      var filePath = componentPaths.get(componentType) || null;
      var namespace = typeof componentType.namespace === 'string' ? componentType.namespace : getCollapsedComponentNamespace(componentPathValues, filePath);
      var name = // Try to read the Class/function name at run-time. User can override
      // this for custom naming
      (0, _inferComponentName.inferComponentName)(componentType) || // Use the name that was used to reference the component in one of its
      // fixtures
      componentNames.get(componentType) || // Fallback to "Component", "Component (1)", "Component (2)", etc.
      defaultComponentNamer(); // Components with duplicate names can end up being squashed (#494), so
      // it's best to keep component names unique.
      // That said, component names only have to be unique under the same namespace

      var nsName = getObjectPath({
        name: name,
        namespace: namespace
      });
      var namer = componentNamers.get(nsName);

      if (!namer) {
        namer = (0, _defaultNamer.createDefaultNamer)(name);
        componentNamers.set(nsName, namer);
      }

      var uniqueName = namer(); // We had to wait until now to be able to determine the common dir between
      // all fixtures belonging to the same component

      var compFixtureCommonDir = (0, _dir.getCommonDir)(compFixtures.map(function (f) {
        return f.filePath;
      }));
      var fixturesWithNamespace = compFixtures.map(function (f) {
        return (0, _objectSpread2.default)({}, f, {
          // Check user specified namespace first, fallback to namespacing based
          // on file path
          namespace: f.source.namespace || getFileNamespace(compFixtureCommonDir, f.filePath)
        });
      });
      components.push({
        filePath: filePath,
        name: uniqueName,
        namespace: namespace,
        type: componentType,
        fixtures: compFixtures ? (0, _lodash.sortBy)(fixturesWithNamespace, getObjectPath) : []
      });
    };

    for (var _iterator = (0, _getIterator2.default)(fixturesByComponent.keys()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _ret = _loop();

      if (_ret === "continue") continue;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return (0, _lodash.sortBy)(components, stripHocNamesFromComponentName);
}

function getFileNameFromPath(filePath) {
  return filePath.split('/').pop().split('.')[0];
}

function getFileNamespace(commonDir, filePath) {
  // Warning: This function works well only when the filePath starts with /
  return filePath ? (0, _dir.getDir)(filePath).slice(commonDir.length + 1) : '';
}

function getCollapsedComponentNamespace(componentPaths, filePath) {
  var componentCommonDir = (0, _dir.getCommonDir)(componentPaths);
  var namespace = getFileNamespace(componentCommonDir, filePath); // Nothing to collapse

  if (!namespace) {
    return namespace;
  }

  var relPath = componentCommonDir ? "".concat(componentCommonDir, "/").concat(namespace) : namespace;
  var componentsAtPath = componentPaths.filter(function (p) {
    return p.indexOf("".concat(relPath, "/")) === 0;
  });

  if (componentsAtPath.length > 1) {
    return namespace;
  } // Collapse path by one level to prevent an extra nesting (eg "Button/Button")
  // when there is only one component in a directory


  return (0, _dir.getDir)(namespace);
}

function warnAboutIncompatFixtures(incompatFixtures, fixtureCommonDir) {
  console.log("[Cosmos] Found ".concat(incompatFixtures.size, " incompatible fixtures:"));
  console.log((0, _toConsumableArray2.default)(incompatFixtures.values()).map(function (f) {
    return "- ".concat(f.slice(fixtureCommonDir.length + 1));
  }).join('\n'));
  console.log('[Cosmos] Enable these fixtures by adding the `component` property.');
  console.log('[Cosmos] More details at https://github.com/react-cosmos/react-cosmos/issues/440');
}

function getObjectPath(obj) {
  return obj.namespace ? "".concat(obj.namespace, "/").concat(obj.name) : obj.name;
}

function stripHocNamesFromComponentName(obj) {
  // withRouter(connect(MyComponent)) -> MyComponent
  // connect(MyComponent)) -> MyComponent
  // MyComponent -> MyComponent
  var componentName = obj.name.replace(/^(.*\()?(.+?)\)*$/, '$2');
  return obj.namespace ? "".concat(obj.namespace, "/").concat(componentName) : componentName;
}
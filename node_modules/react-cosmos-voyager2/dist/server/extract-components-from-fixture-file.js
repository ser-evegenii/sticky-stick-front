"use strict";

var _interopRequireWildcard = require("@babel/runtime-corejs2/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractComponentsFromFixtureFile = extractComponentsFromFixtureFile;

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/slicedToArray"));

var _getIterator2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/get-iterator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));

var _fs = _interopRequireDefault(require("fs"));

var _path = require("path");

var _util = _interopRequireDefault(require("util.promisify"));

var babylon = _interopRequireWildcard(require("babylon"));

var t = _interopRequireWildcard(require("babel-types"));

var _server = require("react-cosmos-shared/server");

var readFileAsync = (0, _util.default)(_fs.default.readFile);
/**
 * Gather info for one or more components from fixture code (statically)
 *
 * Note: There's no 100% guarantee. Components can be inlined in the same file
 * as fixtures, in which case the path returned will be null.
 *
 * TODO: Support CJS
 */

function extractComponentsFromFixtureFile(_x, _x2) {
  return _extractComponentsFromFixtureFile.apply(this, arguments);
}

function _extractComponentsFromFixtureFile() {
  _extractComponentsFromFixtureFile = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee(fixturePath, rootPath) {
    var components, ast, code, body, imports, vars, defaultExportNode, exportBody, fixtureBody, fixtureNodes;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            components = [];
            _context.prev = 1;
            _context.next = 4;
            return readFileAsync(fixturePath, 'utf8');

          case 4:
            code = _context.sent;
            ast = babylon.parse(code, {
              sourceType: 'module',
              // XXX: Does using all plugins have any disadvantage?
              plugins: ['jsx', 'flow', 'typescript', 'objectRestSpread', 'classProperties', 'asyncGenerators', 'dynamicImport']
            });
            _context.next = 12;
            break;

          case 8:
            _context.prev = 8;
            _context.t0 = _context["catch"](1);
            console.log("[Cosmos] Failed to parse ".concat(fixturePath));
            return _context.abrupt("return", components);

          case 12:
            _context.prev = 12;
            body = ast.program.body; // Get a list of all imports and vars to query them later

            imports = body.filter(t.isImportDeclaration);
            vars = body.filter(t.isVariableDeclaration);
            defaultExportNode = body.find(t.isExportDefaultDeclaration);

            if (defaultExportNode) {
              _context.next = 19;
              break;
            }

            throw new Error('Could not find default export in fixture file');

          case 19:
            exportBody = defaultExportNode.declaration; // Sometimes the export is referencing a previously declared var,
            // other times it is declared inline

            fixtureBody = t.isIdentifier(exportBody) ? getVarBodyByName(vars, exportBody.name) : exportBody;

            if (fixtureBody) {
              _context.next = 23;
              break;
            }

            throw new Error('Could not parse fixture export');

          case 23:
            if (t.isArrayExpression(fixtureBody)) {
              fixtureNodes = fixtureBody.elements;
            } else if (fixtureBody) {
              fixtureNodes = [fixtureBody];
            }

            if (fixtureNodes) {
              _context.next = 26;
              break;
            }

            throw new Error('Could not parse fixture contents');

          case 26:
            fixtureNodes.forEach(function (fixtureNode) {
              var name = null;
              var filePath = null;

              try {
                var _fixtureBody = fixtureNode; // Sometimes the fixture is referencing a previously declared var,
                // other times it is declared inline

                if (t.isIdentifier(_fixtureBody)) {
                  _fixtureBody = getVarBodyByName(vars, fixtureNode.name);

                  if (!_fixtureBody) {
                    throw new Error('Could not read fixture body');
                  }
                } // Sometimes the fixture is returned via a proxy function
                // Eg. createFixture({ ... })


                if (t.isCallExpression(_fixtureBody)) {
                  var _fixtureBody$argument = (0, _slicedToArray2.default)(_fixtureBody.arguments, 1);

                  _fixtureBody = _fixtureBody$argument[0];
                }

                if (!t.isObjectExpression(_fixtureBody)) {
                  throw new Error('Could not read fixture body');
                } // $FlowFixMe


                var compProp = findThroughSpread(_fixtureBody, vars);

                if (!compProp) {
                  throw new Error('Fixture component property is missing');
                }

                if (!compProp.value.name) {
                  throw new Error('Fixture component has no name');
                } // From this point we'll return the component name even if we fail to
                // detect the component file path


                name = compProp.value.name;
                var importPath = getImportPathByName(imports, name);

                if (!importPath) {
                  throw new Error('Could not find corresponding component import. ' + 'Maybe the component is declared inside the fixture?');
                } // There are 3 use cases we support here:
                // 1. Relative paths to js files that can be resolved via Node. We
                // resolve path to actual file. Eg: ./Button => /path/to/Button.js
                // 2. Relative paths to non-js files. We resolve this path relative to
                // the fixture dir even if we can't check if file exists.
                // Eg: ./Button => /path/to/Button)
                // 3. Custom resolved module paths. We use as is.
                // Eg: components/Button


                var isModulePath = importPath.match(/^[^./]/);
                filePath = isModulePath ? (0, _server.slash)(rootPath, importPath) : (0, _server.resolveUserPath)((0, _path.dirname)(fixturePath), importPath);
              } catch (err) {// TODO: Allow user to see these errors when debugging
                // console.log(err.message);
              }

              components.push({
                name: name,
                filePath: filePath
              });
            });
            _context.next = 31;
            break;

          case 29:
            _context.prev = 29;
            _context.t1 = _context["catch"](12);

          case 31:
            return _context.abrupt("return", components);

          case 32:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[1, 8], [12, 29]]);
  }));
  return _extractComponentsFromFixtureFile.apply(this, arguments);
}

function getImportPathByName(imports, importName) {
  var relevantImport = imports.find(function (i) {
    return i.specifiers.some(function (s) {
      return s.local.name === importName;
    });
  });
  return relevantImport ? relevantImport.source.value : null;
} // TODO: Find out how to use Flow types with Babel types


function getVarBodyByName(vars, varName) {
  var varBody = null;
  vars.forEach(function (declaration) {
    return declaration.declarations.forEach(function (declarator) {
      if (declarator.id.name === varName) {
        varBody = declarator.init;
      }
    });
  });
  return varBody;
}

function findThroughSpread(node, vars) {
  if (!node) {
    return;
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _getIterator2.default)(node.properties), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var prop = _step.value;

      if (prop.key && prop.key.name === 'component') {
        return prop;
      }

      if (prop.type === 'SpreadProperty') {
        var searchedNode = findThroughSpread(getVarBodyByName(vars, prop.argument.loc.identifierName), vars);

        if (searchedNode) {
          return searchedNode;
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
var lodash_1 = require("lodash");
var react_is_1 = require("react-is");
var reactElementToJSXString = require("react-element-to-jsx-string");
// Why store unserializable values in fixture state?
// - Because they still provides value in the Cosmos UI. They let the user know
//   that, eg. a prop, is present and see the read-only stringified value.
// - More importantly, because the fixture state controls which props to render.
//   This way, if a prop is read-only and cannot be edited in the UI, it can
//   still be removed.
function createValues(obj) {
    return (Object.keys(obj)
        // Ignore noise from attrs defined as undefined (eg. props.children is
        // often `undefined` if element has no children)
        .filter(function (key) { return obj[key] !== undefined; })
        .map(function (key) { return stringifyValue(key, obj[key]); }));
}
exports.createValues = createValues;
// Use fixture state for serializable values and fall back to base values
function extendWithValues(obj, values) {
    return values.reduce(function (acc, _a) {
        var serializable = _a.serializable, key = _a.key, stringified = _a.stringified;
        var _b;
        return (__assign({}, acc, (_b = {}, _b[key] = serializable ? JSON.parse(stringified) : obj[key], _b)));
    }, {});
}
exports.extendWithValues = extendWithValues;
function stringifyValue(key, value) {
    try {
        // NOTE: Is this optimal?
        if (!lodash_1.isEqual(JSON.parse(JSON.stringify(value)), value)) {
            throw new Error('Unserializable value');
        }
    }
    catch (err) {
        return {
            serializable: false,
            key: key,
            // TODO: Enable custom stringifiers to plug in
            stringified: react_is_1.isElement(value)
                ? reactElementToJSXString(value)
                : String(value)
        };
    }
    return {
        serializable: true,
        key: key,
        stringified: JSON.stringify(value)
    };
}

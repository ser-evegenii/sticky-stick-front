"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createServerApp = createServerApp;
exports.createServer = createServer;
exports.serveStaticDir = serveStaticDir;
exports.attachStackFrameEditorLauncher = attachStackFrameEditorLauncher;
exports.getRootUrl = getRootUrl;

var _parseInt2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/parse-int"));

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));

var _path = require("path");

var _http = require("http");

var _util = _interopRequireDefault(require("util.promisify"));

var _express = _interopRequireDefault(require("express"));

var _launchEditor = _interopRequireDefault(require("react-dev-utils/launchEditor"));

var _playgroundHtml = require("./playground-html");

var _httpProxy = require("./http-proxy");

var _configNext = require("./config-next");

// IDEA: Maybe replace react-dev-utils with https://github.com/yyx990803/launch-editor
function createServerApp(_ref) {
  var cosmosConfig = _ref.cosmosConfig,
      playgroundOpts = _ref.playgroundOpts;
  var next = cosmosConfig.next,
      httpProxy = cosmosConfig.httpProxy;
  var app = (0, _express.default)();

  if (httpProxy) {
    (0, _httpProxy.setupHttpProxy)(app, httpProxy);
  }

  var playgroundHtml = next ? (0, _playgroundHtml.getPlaygroundHtmlNext)((0, _configNext.getPlaygroundConfig)({
    playgroundOpts: playgroundOpts,
    devServerOn: true
  })) : (0, _playgroundHtml.getPlaygroundHtml)(playgroundOpts);
  app.get('/', function (req, res) {
    res.send(playgroundHtml);
  });
  app.get('/_playground.js', function (req, res) {
    res.sendFile(require.resolve(next ? 'react-cosmos-playground2' : 'react-cosmos-playground'));
  });
  app.get('/_cosmos.ico', function (req, res) {
    res.sendFile((0, _path.join)(__dirname, 'static/favicon.ico'));
  });
  return app;
}

function createServer(cosmosConfig, app) {
  var port = cosmosConfig.port,
      hostname = cosmosConfig.hostname;
  var server = (0, _http.createServer)(app);

  function startServer() {
    return _startServer.apply(this, arguments);
  }

  function _startServer() {
    _startServer = (0, _asyncToGenerator2.default)(
    /*#__PURE__*/
    _regenerator.default.mark(function _callee() {
      var listen, hostnameDisplay;
      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              listen = (0, _util.default)(server.listen.bind(server));
              _context.next = 3;
              return listen(port, hostname);

            case 3:
              hostnameDisplay = hostname || 'localhost';
              console.log("[Cosmos] See you at http://".concat(hostnameDisplay, ":").concat(port));

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));
    return _startServer.apply(this, arguments);
  }

  function stopServer() {
    return _stopServer.apply(this, arguments);
  }

  function _stopServer() {
    _stopServer = (0, _asyncToGenerator2.default)(
    /*#__PURE__*/
    _regenerator.default.mark(function _callee2() {
      return _regenerator.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return (0, _util.default)(server.close.bind(server))();

            case 2:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));
    return _stopServer.apply(this, arguments);
  }

  return {
    server: server,
    startServer: startServer,
    stopServer: stopServer
  };
}

function serveStaticDir(app, publicUrl, publicPath) {
  var relPublicPath = (0, _path.relative)(process.cwd(), publicPath);
  console.log("[Cosmos] Serving static files from ".concat(relPublicPath));
  app.use(getRootUrl(publicUrl), _express.default.static(publicPath, {
    // Ensure loader index (generated by html-webpack-plugin) loads instead
    // of the index.html from publicPath
    index: false
  }));
}

function attachStackFrameEditorLauncher(app) {
  app.get('/__open-stack-frame-in-editor', function (req, res) {
    var lineNumber = (0, _parseInt2.default)(req.query.lineNumber, 10) || 1;
    var colNumber = (0, _parseInt2.default)(req.query.colNumber, 10) || 1;
    (0, _launchEditor.default)(req.query.fileName, lineNumber, colNumber);
    res.end();
  });
}

function getRootUrl(publicUrl) {
  // To enable deploying static exports running from inside a nested path,
  // publicUrl can be set to `./`.
  // (See https://github.com/react-cosmos/react-cosmos/issues/777)
  // But publicUrl is used in for some paths which must begin with `/`:
  // - As publicPath in webpack-dev-middleware
  // - As the Express path for serving static assets
  // These are server-side modules (running in dev server mode) that only
  // respond to incoming paths which begin with the root URL we specify.
  return publicUrl === './' ? '/' : publicUrl;
}
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));

var _path = require("path");

var _reactCosmosConfig = require("react-cosmos-config");

var _server = require("react-cosmos-shared/server");

var _server2 = require("react-cosmos-shared2/server");

var _configNext = require("../../shared/config-next");

module.exports =
/*#__PURE__*/
function () {
  var _embedModules = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee(source) {
    var _this = this;

    var callback, cosmosConfig, rootDir, watchDirs, globalImports, _ref, fixturePaths, decoratorPaths, res;

    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            callback = this.async();
            cosmosConfig = (0, _reactCosmosConfig.getCosmosConfig)();
            rootDir = cosmosConfig.rootPath, watchDirs = cosmosConfig.watchDirs, globalImports = cosmosConfig.globalImports; // This ensures this loader is invalidated whenever a new file is added to or
            // removed from user's project, which in turn triggers react-cosmos-voyager2
            // to detect fixture files and finally update fixture list inside Playground.
            // Note that while this may not be very performant, it's not the equivalent
            // of require.context, which not only watches for file changes but also
            // automatically bundles new files that match the watcher's query.
            // https://github.com/webpack/webpack/issues/222#issuecomment-40691546

            watchDirs.forEach(function (watchDir) {
              return _this.addContextDependency(watchDir);
            });
            _context.next = 6;
            return (0, _server2.findUserModulePaths)({
              rootDir: rootDir,
              fixturesDir: _configNext.FIXTURES_DIR,
              fixtureFileSuffix: _configNext.FIXTURE_FILE_SUFFIX
            });

          case 6:
            _ref = _context.sent;
            fixturePaths = _ref.fixturePaths;
            decoratorPaths = _ref.decoratorPaths;
            res = source.replace("/* __INJECT_GLOBAL_IMPORTS__ */", globalImports.map(function (importPath) {
              return "require('".concat(importPath, "');");
            }).join("\n")).replace('= __COSMOS_FIXTURES', "= ".concat(genModuleMapStr({
              paths: fixturePaths,
              rootDir: rootDir
            }))).replace('= __COSMOS_DECORATORS', "= ".concat(genModuleMapStr({
              paths: decoratorPaths,
              rootDir: rootDir
            })));
            callback(null, res);

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function embedModules(_x) {
    return _embedModules.apply(this, arguments);
  };
}();

function genModuleMapStr(_ref2) {
  var paths = _ref2.paths,
      rootDir = _ref2.rootDir;

  if (paths.length === 0) {
    return '{}';
  }

  return "{".concat(paths.map(function (path) {
    return getModuleStr({
      path: path,
      rootDir: rootDir
    });
  }).join(', '), "\n}");
}

function getModuleStr(_ref3) {
  var path = _ref3.path,
      rootDir = _ref3.rootDir;
  var relPath = (0, _server.slash)((0, _path.relative)(rootDir, path));
  return "\n  '".concat(relPath, "': require('").concat(path, "').default"); // TODO: Support multiple named exports (as well as CJS modules)
  // return `
  // '${cleanPath}': {
  //   filePath: '${path}',
  //   exports: require('${path}')
  // }`;
}
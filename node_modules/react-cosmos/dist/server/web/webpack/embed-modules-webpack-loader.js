"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _stringify = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/json/stringify"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));

var _reactCosmosConfig = require("react-cosmos-config");

var _server = require("react-cosmos-shared/server");

var _reactCosmosVoyager = _interopRequireDefault(require("react-cosmos-voyager"));

var _server2 = require("react-cosmos-voyager2/server");

var keys = _keys.default;
/**
 * Inject require calls in bundle for each component/fixture path and
 * add entire project path as a context dependency. Tells webpack to
 * - Bundle all necessary component/fixture modules
 * - Watch for (and react to) added and changed component/fixture files
 */

module.exports =
/*#__PURE__*/
function () {
  var _embedModules = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee(source) {
    var _this = this;

    var callback, cosmosConfig, proxiesPath, watchDirs, _ref, fixtureFiles, deprecatedComponentModules, fixturePaths, fixtureModuleCalls, componentModuleCallls, result;

    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            callback = this.async();
            cosmosConfig = (0, _reactCosmosConfig.getCosmosConfig)();
            proxiesPath = cosmosConfig.proxiesPath, watchDirs = cosmosConfig.watchDirs;
            _context.next = 5;
            return getNormalizedModules(cosmosConfig);

          case 5:
            _ref = _context.sent;
            fixtureFiles = _ref.fixtureFiles;
            deprecatedComponentModules = _ref.deprecatedComponentModules;
            fixturePaths = getFixturePaths(fixtureFiles);
            fixtureModuleCalls = convertPathsToRequireCalls(fixturePaths);
            componentModuleCallls = convertPathsToRequireCalls(keys(deprecatedComponentModules).map(function (c) {
              return deprecatedComponentModules[c];
            })); // This ensures this loader is invalidated whenever a new file is added to or
            // removed from user's project, which in turn triggers react-cosmos-voyager2
            // to detect fixture files and finally update fixture list inside Playground.
            // Note that while this may not be very performant, it's not the equivalent
            // of require.context, which not only watches for file changes but also
            // automatically bundles new files that match the watcher's query.
            // https://github.com/webpack/webpack/issues/222#issuecomment-40691546

            watchDirs.forEach(function (watchDir) {
              return _this.addContextDependency(watchDir);
            });
            result = source.replace(/FIXTURE_MODULES/g, fixtureModuleCalls).replace(/FIXTURE_FILES/g, (0, _stringify.default)(fixtureFiles)).replace(/DEPRECATED_COMPONENT_MODULES/g, componentModuleCallls).replace(/PROXIES/g, (0, _server.moduleExists)(proxiesPath) ? convertPathToRequireCall(proxiesPath) : '[]');
            callback(null, result);

          case 14:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function embedModules(_x) {
    return _embedModules.apply(this, arguments);
  };
}();

function getNormalizedModules(_x2) {
  return _getNormalizedModules.apply(this, arguments);
}

function _getNormalizedModules() {
  _getNormalizedModules = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee2(cosmosConfig) {
    var componentPaths, _getFilePaths, components, fixtures, _fixtureFiles, rootPath, fileMatch, fileMatchIgnore, exclude, fixtureFiles;

    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            componentPaths = cosmosConfig.componentPaths;

            if (!(componentPaths.length > 0)) {
              _context2.next = 7;
              break;
            }

            console.warn('[Cosmos] Using `componentPaths` config is deprecated. ' + 'Please consider upgrading.');
            _getFilePaths = (0, _reactCosmosVoyager.default)(cosmosConfig), components = _getFilePaths.components, fixtures = _getFilePaths.fixtures;
            _fixtureFiles = []; // Convert old format to new format

            keys(fixtures).forEach(function (componentName) {
              keys(fixtures[componentName]).forEach(function (fixtureName) {
                _fixtureFiles.push({
                  filePath: fixtures[componentName][fixtureName],
                  components: [{
                    name: componentName,
                    filePath: components[componentName]
                  }]
                });
              });
            });
            return _context2.abrupt("return", {
              fixtureFiles: _fixtureFiles,
              deprecatedComponentModules: components
            });

          case 7:
            rootPath = cosmosConfig.rootPath, fileMatch = cosmosConfig.fileMatch, fileMatchIgnore = cosmosConfig.fileMatchIgnore, exclude = cosmosConfig.exclude;
            _context2.next = 10;
            return (0, _server2.findFixtureFiles)({
              rootPath: rootPath,
              fileMatch: fileMatch,
              fileMatchIgnore: fileMatchIgnore,
              exclude: exclude
            });

          case 10:
            fixtureFiles = _context2.sent;
            return _context2.abrupt("return", {
              fixtureFiles: fixtureFiles,
              deprecatedComponentModules: {}
            });

          case 12:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _getNormalizedModules.apply(this, arguments);
}

function getFixturePaths(files) {
  return files.map(function (file) {
    return file.filePath;
  });
}

function convertPathsToRequireCalls(paths) {
  var entries = paths.map(function (p) {
    return "'".concat(p, "':").concat(convertPathToRequireCall(p));
  });
  return "{".concat(entries.join(','), "}");
}

function convertPathToRequireCall(p) {
  return "require('".concat(p, "')");
}
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = enhanceWebpackConfig;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _objectSpread3 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/objectSpread"));

var _stringify = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/json/stringify"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/toConsumableArray"));

var _path = require("path");

var _lodash = require("lodash");

var _importFrom = require("import-from");

var _reactCosmosConfig = require("react-cosmos-config");

function enhanceWebpackConfig(_ref) {
  var webpack = _ref.webpack,
      userWebpackConfig = _ref.userWebpackConfig,
      _ref$shouldExport = _ref.shouldExport,
      shouldExport = _ref$shouldExport === void 0 ? false : _ref$shouldExport;
  var cosmosConfig = (0, _reactCosmosConfig.getCosmosConfig)();
  var next = cosmosConfig.next,
      rootPath = cosmosConfig.rootPath,
      containerQuerySelector = cosmosConfig.containerQuerySelector,
      hot = cosmosConfig.hot,
      publicUrl = cosmosConfig.publicUrl,
      webpackOverride = cosmosConfig.webpack;
  var webpackConfig = userWebpackConfig;

  if (typeof webpackOverride === 'function') {
    console.log("[Cosmos] Overriding webpack config");
    webpackConfig = webpackOverride(webpackConfig, {
      env: getEnv()
    });
  }

  var entry = getEntry(cosmosConfig, shouldExport);
  var output = getOutput(cosmosConfig, shouldExport);
  var rules = (0, _toConsumableArray2.default)(getExistingRules(webpackConfig)).concat([next ? {
    loader: require.resolve('./embed-modules-webpack-loader-next'),
    include: require.resolve('../../../client/next/userModules')
  } : {
    loader: require.resolve('./embed-modules-webpack-loader'),
    include: require.resolve('../../../client/user-modules')
  }]);
  var plugins = (0, _toConsumableArray2.default)(getExistingPlugins(webpackConfig)).concat([new webpack.DefinePlugin({
    // Having __DEV__ as boolean is useful because if (__DEV__) blocks will
    // get stripped automatically when compiling a static export build
    __DEV__: (0, _stringify.default)(!shouldExport),
    'process.env': {
      NODE_ENV: (0, _stringify.default)(shouldExport ? 'production' : 'development'),
      PUBLIC_URL: (0, _stringify.default)(removeTrailingSlash(publicUrl))
    }
  }), new webpack.DefinePlugin({
    COSMOS_CONFIG: (0, _stringify.default)({
      // Config options that are available inside the client bundle. Warning:
      // Must be serializable!
      containerQuerySelector: containerQuerySelector
    })
  }), getNoErrorsPlugin(webpack)]);

  if (!alreadyHasPlugin(webpackConfig, 'HtmlWebpackPlugin')) {
    var HtmlWebpackPlugin = (0, _importFrom.silent)(rootPath, 'html-webpack-plugin');

    if (HtmlWebpackPlugin) {
      plugins = (0, _toConsumableArray2.default)(plugins).concat([new HtmlWebpackPlugin({
        title: 'React Cosmos',
        filename: '_loader.html'
      })]);
    }
  }

  if (hot && !shouldExport) {
    if (!alreadyHasPlugin(webpackConfig, 'HotModuleReplacementPlugin')) {
      plugins = (0, _toConsumableArray2.default)(plugins).concat([new webpack.HotModuleReplacementPlugin()]);
    }
  }

  return (0, _objectSpread3.default)({}, webpackConfig, {
    entry: entry,
    output: output,
    module: extendModuleWithRules(webpackConfig, rules),
    plugins: plugins
  });
}

function getEntry(_ref2, shouldExport) {
  var next = _ref2.next,
      globalImports = _ref2.globalImports,
      hot = _ref2.hot;
  // The React devtools hook needs to be imported before any other module which
  // might import React
  var entry = [resolveClientPath('react-devtools-hook')]; // Global imports are injected in the user modules file in Cosmos Next, to
  // make them hot reload-able

  if (!next) {
    entry = (0, _toConsumableArray2.default)(entry).concat((0, _toConsumableArray2.default)(globalImports));
  }

  if (hot && !shouldExport) {
    entry = (0, _toConsumableArray2.default)(entry).concat(["".concat(require.resolve('webpack-hot-middleware/client'), "?reload=true&overlay=false")]);
  }

  return (0, _toConsumableArray2.default)(entry).concat([resolveClientPath(next ? 'next' : 'loader-entry')]);
}

function resolveClientPath(p) {
  return require.resolve("../../../client/".concat(p));
}

function getOutput(_ref3, shouldExport) {
  var outputPath = _ref3.outputPath,
      publicUrl = _ref3.publicUrl;
  var filename = '[name].js';

  if (shouldExport) {
    return {
      // Most paths are created using forward slashes regardless of the OS for
      // consistency, but this one needs to have backslashes on Windows!
      path: (0, _path.join)(outputPath, publicUrl),
      filename: filename,
      publicPath: publicUrl
    };
  }

  return {
    // Setting path to `/` in development (where files are saved in memory and
    // not on disk) is a weird required for old webpack versions
    path: '/',
    filename: filename,
    publicPath: publicUrl,
    // Enable click-to-open source in react-error-overlay
    devtoolModuleFilenameTemplate: function devtoolModuleFilenameTemplate(info) {
      return (0, _path.resolve)(info.absoluteResourcePath).replace(/\\/g, '/');
    }
  };
}

function getWebpackRulesOptionName(webpackConfig) {
  // To support webpack 1 and 2 configuration formats, we use the one that
  // user passes
  return webpackConfig.module && webpackConfig.module.loaders ? 'loaders' : 'rules';
}

function getExistingRules(webpackConfig) {
  var webpackRulesOptionName = getWebpackRulesOptionName(webpackConfig);
  return webpackConfig.module && webpackConfig.module[webpackRulesOptionName] ? (0, _toConsumableArray2.default)(webpackConfig.module[webpackRulesOptionName]) : [];
}

function extendModuleWithRules(webpackConfig, rules) {
  var webpackRulesOptionName = getWebpackRulesOptionName(webpackConfig);
  return (0, _objectSpread3.default)({}, (0, _lodash.omit)(webpackConfig.module, 'rules', 'loaders'), (0, _defineProperty2.default)({}, webpackRulesOptionName, rules));
}

function getExistingPlugins(webpackConfig) {
  var plugins = webpackConfig.plugins ? (0, _toConsumableArray2.default)(webpackConfig.plugins) : [];
  return plugins.map(function (plugin) {
    return isPluginType(plugin, 'HtmlWebpackPlugin') ? changeHtmlPluginFilename(plugin) : plugin;
  });
}

function changeHtmlPluginFilename(htmlPlugin) {
  if (htmlPlugin.options.filename !== 'index.html') {
    return htmlPlugin;
  }

  return new htmlPlugin.constructor((0, _objectSpread3.default)({}, htmlPlugin.options, {
    filename: '_loader.html'
  }));
}

function getNoErrorsPlugin(webpack) {
  // Important: Without this webpack tries to apply hot updates for broken
  // builds and results in duplicate React nodes attached
  // See https://github.com/webpack/webpack/issues/2117
  // Note: NoEmitOnErrorsPlugin replaced NoErrorsPlugin since webpack 2.x
  return webpack.NoEmitOnErrorsPlugin ? new webpack.NoEmitOnErrorsPlugin() : new webpack.NoErrorsPlugin();
}

function alreadyHasPlugin(_ref4, pluginName) {
  var plugins = _ref4.plugins;
  return plugins && plugins.filter(function (p) {
    return isPluginType(p, pluginName);
  }).length > 0;
}

function isPluginType(plugin, constructorName) {
  return plugin.constructor && plugin.constructor.name === constructorName;
}

function removeTrailingSlash(str) {
  return str.replace(/\/$/, '');
}

function getEnv() {
  return process.env.NODE_ENV || 'development';
}
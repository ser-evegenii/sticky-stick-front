"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _now = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/date/now"));

module.exports = function until(cb) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var failMsg = opts.failMsg,
      _opts$timeout = opts.timeout,
      timeout = _opts$timeout === void 0 ? 300 : _opts$timeout,
      _opts$loopDelay = opts.loopDelay,
      loopDelay = _opts$loopDelay === void 0 ? 0 : _opts$loopDelay,
      _opts$minLoops = opts.minLoops,
      minLoops = _opts$minLoops === void 0 ? 3 : _opts$minLoops;
  var t1 = (0, _now.default)();
  return new _promise.default(function (resolve, reject) {
    // Why the loop count if we already have a timeout? Well, say something
    // happens and our program freezes for a timeout + 1ms duration. The
    // callback will run in the next loop and instantly expire if the condition
    // isn't met. Sometimes our app releases a chain of async callbacks that
    // need to fulfill before our condition is met, so the min loop count
    // ensures we don't bail too soon in case of a hiccup.
    var loopCount = 0;

    function loop() {
      return _loop.apply(this, arguments);
    }

    function _loop() {
      _loop = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee() {
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                loopCount += 1;
                _context.next = 3;
                return run();

              case 3:
                if (!_context.sent) {
                  _context.next = 7;
                  break;
                }

                resolve(true);
                _context.next = 8;
                break;

              case 7:
                if ((0, _now.default)() - t1 < timeout || loopCount < minLoops) {
                  setTimeout(loop, loopDelay);
                } else {
                  reject(new Error(failMsg || getDefaultMessage(cb)));
                }

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));
      return _loop.apply(this, arguments);
    }

    function run() {
      return _run.apply(this, arguments);
    } // Kick it


    function _run() {
      _run = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee2() {
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.prev = 0;
                return _context2.abrupt("return", cb());

              case 4:
                _context2.prev = 4;
                _context2.t0 = _context2["catch"](0);
                reject(_context2.t0);

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[0, 4]]);
      }));
      return _run.apply(this, arguments);
    }

    loop();
  });
};

function getDefaultMessage(cb) {
  return "Timeout expired. Condition wasn't met: ".concat(cb);
}
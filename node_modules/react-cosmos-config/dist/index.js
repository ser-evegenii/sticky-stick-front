"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCosmosConfig = getCosmosConfig;
exports.hasUserCosmosConfig = hasUserCosmosConfig;
exports.generateCosmosConfig = generateCosmosConfig;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/objectSpread"));

var _fs = require("fs");

var _path = require("path");

var _yargs = require("yargs");

var _reactCosmosShared = require("react-cosmos-shared");

var _server = require("react-cosmos-shared/server");

var _log = require("./log");

var _configTemplates = require("./config-templates");

var defaults = {
  rootPath: '.',
  fileMatch: _server.defaultFileMatch,
  fileMatchIgnore: _server.defaultFileMatchIgnore,
  exclude: _server.defaultExclude,
  globalImports: [],
  // From Node.js docs: If host is omitted, the server will accept connections
  // on the unspecified IPv6 address (::) when IPv6 is available, or the
  // unspecified IPv4 address (0.0.0.0) otherwise.
  // This is particularly useful when running Cosmos inside a Docker container
  // https://github.com/react-cosmos/react-cosmos/issues/639
  hostname: null,
  hot: true,
  port: 8989,
  proxiesPath: 'cosmos.proxies',
  webpackConfigPath: 'webpack.config',
  outputPath: 'cosmos-export',
  publicUrl: '/',
  watchDirs: ['.'],
  // Only used by the React Native server, modulesPath specifies where to
  // generate the file with imports to all user fixtures and proxies.
  // Whereas most of the other paths are used to import modules, modulesPath is
  // used as an output file path and it requires a file extension.
  modulesPath: 'cosmos.modules.js',
  plugin: {},
  // Deprecated
  componentPaths: [],
  ignore: [],
  fixturesDir: '__fixtures__',
  fixturePaths: []
};

function getCosmosConfig(cosmosConfigPath) {
  var configPath = getUserConfigPath(cosmosConfigPath);
  var relPath = (0, _path.dirname)(configPath);

  if (!configExist(configPath)) {
    if (_yargs.argv.config) {
      var _relPath = (0, _path.relative)(process.cwd(), configPath);

      (0, _log.warn)("[Cosmos] No config file found at ".concat(_relPath, ", using defaults"));
    } else {
      (0, _log.log)("[Cosmos] No config file found, using defaults");
    }

    return getNormalizedConfig(defaults, relPath);
  }

  var userConfig = (0, _reactCosmosShared.importModule)(require(configPath));
  var config = (0, _objectSpread2.default)({}, defaults, userConfig);
  return getNormalizedConfig(config, relPath);
}

function hasUserCosmosConfig() {
  return configExist(getUserConfigPath());
}

function generateCosmosConfig() {
  // Warning: This code assumes the user hasn't created cosmos.config by now
  var configPath = getUserConfigPath();
  var rootPath = (0, _path.dirname)(configPath);
  var craWebpackConfigPath = 'react-scripts/config/webpack.config.dev';

  if ((0, _server.moduleExists)((0, _server.resolveUserPath)(rootPath, craWebpackConfigPath))) {
    (0, _fs.writeFileSync)(configPath, _configTemplates.CRA_COSMOS_CONFIG, 'utf8');
    return 'Create React App';
  }
}

function getUserConfigPath(customConfigPath) {
  var loosePath = (0, _path.resolve)(process.cwd(), customConfigPath || _yargs.argv.config || 'cosmos.config.js'); // Ensure path has file extension

  return loosePath.match(/\.js$/) ? loosePath : "".concat(loosePath, ".js");
}

function configExist(path) {
  // Only resolve config path once we know it exists, otherwise the path will
  // be cached to a missing module for the rest of the process execution.
  // This allows us to generate the config at run time and import it later.
  return (0, _fs.existsSync)(path);
}

function getNormalizedConfig(relativeConfig, relPath) {
  var globalImports = relativeConfig.globalImports,
      outputPath = relativeConfig.outputPath,
      proxiesPath = relativeConfig.proxiesPath,
      publicPath = relativeConfig.publicPath,
      webpackConfigPath = relativeConfig.webpackConfigPath,
      watchDirs = relativeConfig.watchDirs,
      modulesPath = relativeConfig.modulesPath,
      componentPaths = relativeConfig.componentPaths,
      fixturePaths = relativeConfig.fixturePaths;
  var rootPath = (0, _server.slash)((0, _path.resolve)(relPath, relativeConfig.rootPath));
  var config = (0, _objectSpread2.default)({}, relativeConfig, {
    rootPath: rootPath,
    globalImports: globalImports.map(function (p) {
      return (0, _server.resolveUserPath)(rootPath, p);
    }),
    outputPath: (0, _server.slash)((0, _path.resolve)(rootPath, outputPath)),
    proxiesPath: (0, _server.resolveUserPath)(rootPath, proxiesPath),
    webpackConfigPath: (0, _server.resolveUserPath)(rootPath, webpackConfigPath),
    watchDirs: watchDirs.map(function (p) {
      return (0, _server.slash)((0, _path.resolve)(rootPath, p));
    }),
    modulesPath: (0, _server.resolveUserPath)(rootPath, modulesPath),
    // Deprecated
    componentPaths: componentPaths.map(function (p) {
      return (0, _server.slash)((0, _path.resolve)(rootPath, p));
    }),
    fixturePaths: fixturePaths.map(function (p) {
      return (0, _server.slash)((0, _path.resolve)(rootPath, p));
    })
  });

  if (publicPath) {
    config.publicPath = (0, _server.slash)((0, _path.resolve)(rootPath, publicPath));
  }

  return config;
}